#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  armLim,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           flWheel,       tmotorVex393TurboSpeed_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           frWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           blArm,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           tlArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rIntake,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lIntake,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           brArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           trArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           brWheel,       tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port10,          blWheel,       tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rkUtil001.h"
#include "rkPid001.h"
#include "rkCompetition001.h"

#define masterLWheel blWheel
#define masterRWheel brWheel
#define masterArm blArm

#define setArms(val) motor[blArm] = motor[tlArm] = motor[brArm] = motor[trArm] = val

task updatePids() {
  while(isPidRunning) {
    if(driveLPid.doRun) {
      motor[flWheel] = motor[blWheel] = calcPid(driveLPid);
    }
    if(driveRPid.doRun) {
      motor[frWheel] = motor[brWheel] = calcPid(driveRPid);
    }
    if(armPid.doRun) {
      setArms(calcPid(armPid));
    }
    EndTimeSlice();
  }
}

//Cheater-cube autonomous subroutine
void autonChCube() {
  movePid(&armPid, 500, 63);

  block(!armPid.isOnTarget);

  movePid(&armPid, 0, 127);

  block(!armPid.isOnTarget);
}

task autonLineAlignIntake() {
  motor[lIntake] = motor[rIntake] = 63;

  wait1Msec(30);

  motor[lIntake] = motor[rIntake] = 0;
}

//Blue-post straight-line autonomous subroutine
void autonALine() {
  startTask(autonLineAlignIntake);

  movePid(&driveLPid, 280, 127);
  lockPid(&driveRPid);

  block(!driveLPid.isOnTarget);

  movePidBy(&driveLPid, 275, 57);
  movePidBy(&driveRPid, 275, 57);

  block(!driveLPid.isOnTarget || !driveRPid.isOnTarget);

  //lockPid(&driveLPid);
  //lockPid(&driveRPid);

  motor[lIntake] = motor[rIntake] = 127;

  wait1Msec(450);

  motor[lIntake] = motor[rIntake] = 0;

  movePidBy(&driveLPid, 150);
  movePidBy(&driveRPid, 150);

  block(!driveLPid.isOnTarget || !driveRPid.isOnTarget);

  lockPid(&driveLPid);
  movePidBy(&driveRPid, 600);

  block(!driveRPid.isOnTarget);

  movePidBy(&driveLPid, 300);
  movePidBy(&driveRPid, 300);

  block(!driveLPid.isOnTarget || !driveRPid.isOnTarget);

  lockPid(&driveLPid);
  lockPid(&driveRPid);

  motor[lIntake] = motor[rIntake] = 127;

  wait1Msec(500);

  motor[lIntake] = motor[rIntake] = 0;
}

void init() {
  clearLCDLine(0);

  initPid(&driveLPid, masterLWheel, true, 20, .85, 20, .63);
  initPid(&driveRPid, masterRWheel, true, 20, .85, 20, .63);
  initPid(&armPid   , masterArm   , true, 10, .63, 20, .4);
  stopAllPids();

  setArms(-31);

  block(!SensorValue[armLim]);

  setArms(0);

  wait1Msec(100);

  clearPidEncoder(&armPid);
  clearPidEncoder(&driveLPid);
  clearPidEncoder(&driveRPid);
}

task auton() {
  stopAllPids();
  beginPid(&armPid);
  beginPid(&driveLPid, true);
  beginPid(&driveRPid, true);

  autonChCube();

  autonALine();

  endAuton();
}

void endAuton() {
  motor[flWheel] = motor[frWheel] = setArms(0);
  stopPid(&driveLPid);
  stopPid(&driveRPid);
  stopPid(&armPid);
  stopAllPids();
}

void endUserOp() {
}

task userOp() {
  short digiVelArm, digiVelIntake;
  while (true) {
  motor[frWheel] = motor[brWheel] = abs(vexRT[Ch2]) > 3 ? vexRT[Ch2] : 0;
  motor[flWheel] = motor[blWheel] = abs(vexRT[Ch3]) > 3 ? vexRT[Ch3] : 0;

  digiVelArm = vexRT[Btn7D] ? 63 : 127;
  digiVelIntake = vexRT[Btn8D] ? 63 : 127;

  setArms((vexRT[Btn5U] ^ vexRT[Btn5D]) ? (vexRT[Btn5U] ? digiVelArm : SensorValue[armLim] ? 0 : -digiVelArm) : SensorValue[armLim] ? -10 : 20);

    motor[lIntake] = motor[rIntake] =
  (vexRT[Btn6U] ^ vexRT[Btn6D]) ? (vexRT[Btn6U] ? digiVelIntake : -digiVelIntake) : 0;
  }
}
