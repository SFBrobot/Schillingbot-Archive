#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  armLim,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           flWheel,       tmotorVex393TurboSpeed_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           frWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           blArm,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           tlArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rIntake,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lIntake,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           brArm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           trArm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           brWheel,       tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port10,          blWheel,       tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#define max(a, b) (a > b ? a : b)
#define min(a, b) (a > b ? b : a)

#define masterLWheel blWheel
#define masterRWheel brWheel
#define masterArm blArm

#define setArms(val) motor[blArm] = motor[tlArm] =\
	motor[brArm] = motor[trArm] = val

typedef struct {
  tMotor motor; //Master motor port
  bool useMotorEncoder, isOnTarget; //Use I2C? and is motor within threshold
  tSensors enc; //Encoder connected to motor
  short setPoint, thresh, kI, lastError; //Rotation setpoint, threshold, I coefficient, and last error value (for derivative)
  long lastTime; //Last time (for derivative)
  float kP, kD; //P and D coefficients
  bool doRun; //Should we update this?
} Pid;

short getPidEncoder(Pid* pid) {
	return pid->useMotorEncoder ? nMotorEncoder[pid->motor] : SensorValue[pid->enc];
}

short getPidError(Pid* pid) {
  short error = pid->setPoint - getPidEncoder(pid);
  pid->isOnTarget = abs(error) <= pid->thresh;
  return pid->isOnTarget ? 0 : error;
}

short calcPid(Pid* pid) {
  short error = getPidError(pid);

  if(error == 0) return 0;

  short mtrPwr = 0;
  long time = time1[T4];

  mtrPwr = max(-128, min(127, mtrPwr + pid->kP * error)); //Calculate proportional power
  mtrPwr = max(-128, min(127, mtrPwr + sgn(error) * pid->kI)); //Calculate integral power
  if(time > pid->lastTime) mtrPwr = max(-128, min(127, mtrPwr + pid->kD * (float)(pid->lastError - error) / (float)(time - pid->lastTime))); //Calculate derivative power

  pid->lastError = error;
  pid->lastTime = time;

  return mtrPwr;
}

short updatePid(Pid* pid) {
  return motor[pid->motor] = calcPid(pid);
}

void initPid(Pid* pid, tMotor motor, bool useMotorEncoder, short thresh, float kP, short kI, float kD) {
  pid->motor = motor;
  pid->useMotorEncoder = useMotorEncoder;
  if(!useMotorEncoder) pid->enc = getEncoderForMotor(motor);
  pid->setPoint = 0;
  pid->lastError = 0;
  pid->lastTime = 0;
  pid->doRun = false;
  pid->thresh = thresh;
  pid->kP = kP;
  pid->kI = kI;
  pid->kD = kD;
}

Pid driveLPid, driveRPid, armPid;

bool isPidRunning = false;
task updatePids() {
  while(isPidRunning) {
		if(driveLPid.doRun) {
			motor[flWheel] = motor[blWheel] = calcPid(driveLPid);
		}
		if(driveRPid.doRun) {
			motor[frWheel] = motor[brWheel] = calcPid(driveRPid);
		}
		if(armPid.doRun) {
			setArms(calcPid(armPid));
		}
		EndTimeSlice();
  }
}

void beginPid(Pid* pid) {
  if(!isPidRunning) {
    isPidRunning = true;
    startTask(updatePids);
    clearTimer(T4);
  }
  pid->doRun = true;
	pid->isOnTarget = false;
  pid->lastTime = time1[T4];
  pid->lastError = getPidError(pid);
}

void movePid(Pid* pid, short setPoint) {
	pid->setPoint = setPoint;
	beginPid(pid);
}

void stopPid(Pid* pid) {
	if(pid->doRun) {
  	pid->doRun = false;
    motor[pid->motor] = 0;
  }
}

void stopAllPids() {
  isPidRunning = false;
}

void pre_auton() {
  bStopTasksBetweenModes = true;
  initPid(&driveLPid, masterLWheel, true, 2, .63, 20, .63);
  initPid(&driveRPid, masterRWheel, true, 2, .63, 20, .63);
  initPid(&armPid   , masterArm   , true, 2, .63, 20, .63);

  setArms(-31);

  while(!SensorValue[armLim]);

  wait1Msec(100);

  setArms(0);

  nMotorEncoder[masterArm] =
  	nMotorEncoder[masterLWheel] =
  	nMotorEncoder[masterRWheel] = 0;
}

task autonomous() {
	movePid(&armPid, 500);
	beginPid(&driveLPid);
	beginPid(&driveRPid);

	while(!armPid.isOnTarget);

	movePid(&armPid, 0);

	while(!armPid.isOnTarget);

	while(true);

	stopPid(&driveLPid);
	stopPid(&driveRPid);
	stopPid(&armPid);
	stopAllPids();
	//while (SensorValue[I2C_3] < 225) {
 // 	motor[blArm] = 127;
 // 	motor[brArm] = 127;
 // 	motor[trArm] = 127;
 // 	motor[tlArm] = 127;
 // }

 // while (SensorValue[I2C_3] > 0) {
 // 	motor[blArm] = -127;
 // 	motor[brArm] = -127;
 // 	motor[trArm] = -127;
 // 	motor[tlArm] = -127;
 // }

 // if (SensorValue[I2C_3] == 0) {
 // 	motor[blArm] = 0;
 // 	motor[brArm] = 0;
 // 	motor[trArm] = 0;
 // 	motor[tlArm] = 0;
 // }

}

task usercontrol() {
	short digiVelArm, digiVelIntake;
  while (true) {
    motor[frWheel] = motor[brWheel] = abs(vexRT[Ch2]) > 3 ? vexRT[Ch2] : 0;
    motor[flWheel] = motor[blWheel] = abs(vexRT[Ch3]) > 3 ? vexRT[Ch3] : 0;

    digiVelArm = vexRT[Btn7D] ? 127 : 63;
    digiVelIntake = vexRT[Btn8D] ? 127 : 63;

    setArms((vexRT[Btn5U] ^ vexRT[Btn5D]) ? (vexRT[Btn5U] ? digiVelArm : -digiVelArm) : 0);

    motor[lIntake] = motor[rIntake] =
    	(vexRT[Btn6U] ^ vexRT[Btn6D]) ? (vexRT[Btn6U] ? digiVelIntake : -digiVelIntake) : 0;
  }
}
